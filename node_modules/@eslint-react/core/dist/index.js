import { AST_NODE_TYPES } from "@typescript-eslint/types";
import * as AST from "@eslint-react/ast";
import { constFalse, constTrue, dual, flip, getOrElseUpdate, identity, unit } from "@eslint-react/eff";
import { RE_ANNOTATION_JSX, RE_ANNOTATION_JSX_FRAG, RE_ANNOTATION_JSX_IMPORT_SOURCE, RE_ANNOTATION_JSX_RUNTIME, RE_COMPONENT_NAME, RE_COMPONENT_NAME_LOOSE } from "@eslint-react/kit";
import { getId } from "@eslint-react/shared";
import { findProperty, findVariable, getVariableDefinitionNode, isNodeValueEqual } from "@eslint-react/var";
import { getStaticValue } from "@typescript-eslint/utils/ast-utils";
import { P, isMatching, match } from "ts-pattern";
import birecord from "birecord";

//#region src/utils/is-react-api.ts
function isReactAPI(api) {
	const func = (context, node) => {
		if (node == null) return false;
		const getText = (n) => context.sourceCode.getText(n);
		const name = AST.toStringFormat(node, getText);
		if (name === api) return true;
		if (name.substring(name.indexOf(".") + 1) === api) return true;
		return false;
	};
	return dual(2, func);
}
function isReactAPICall(api) {
	const func = (context, node) => {
		if (node == null) return false;
		if (node.type !== AST_NODE_TYPES.CallExpression) return false;
		return isReactAPI(api)(context, node.callee);
	};
	return dual(2, func);
}
const isCaptureOwnerStack = isReactAPI("captureOwnerStack");
const isChildrenCount = isReactAPI("Children.count");
const isChildrenForEach = isReactAPI("Children.forEach");
const isChildrenMap = isReactAPI("Children.map");
const isChildrenOnly = isReactAPI("Children.only");
const isChildrenToArray = isReactAPI("Children.toArray");
const isCloneElement = isReactAPI("cloneElement");
const isCreateContext = isReactAPI("createContext");
const isCreateElement = isReactAPI("createElement");
const isCreateRef = isReactAPI("createRef");
const isForwardRef = isReactAPI("forwardRef");
const isMemo = isReactAPI("memo");
const isLazy = isReactAPI("lazy");
const isCaptureOwnerStackCall = isReactAPICall("captureOwnerStack");
const isChildrenCountCall = isReactAPICall("Children.count");
const isChildrenForEachCall = isReactAPICall("Children.forEach");
const isChildrenMapCall = isReactAPICall("Children.map");
const isChildrenOnlyCall = isReactAPICall("Children.only");
const isChildrenToArrayCall = isReactAPICall("Children.toArray");
const isCloneElementCall = isReactAPICall("cloneElement");
const isCreateContextCall = isReactAPICall("createContext");
const isCreateElementCall = isReactAPICall("createElement");
const isCreateRefCall = isReactAPICall("createRef");
const isForwardRefCall = isReactAPICall("forwardRef");
const isMemoCall = isReactAPICall("memo");
const isLazyCall = isReactAPICall("lazy");

//#endregion
//#region src/component/component-children.ts
/**
* Determines whether inside `createElement`'s children.
* @param context The rule context
* @param node The AST node to check
* @returns `true` if the node is inside createElement's children
*/
function isChildrenOfCreateElement(context, node) {
	const parent = node.parent;
	if (parent == null || parent.type !== AST_NODE_TYPES.CallExpression) return false;
	if (!isCreateElementCall(context, parent)) return false;
	return parent.arguments.slice(2).some((arg) => arg === node);
}

//#endregion
//#region src/hook/hook-name.ts
const REACT_BUILTIN_HOOK_NAMES = [
	"use",
	"useActionState",
	"useCallback",
	"useContext",
	"useDebugValue",
	"useDeferredValue",
	"useEffect",
	"useFormStatus",
	"useId",
	"useImperativeHandle",
	"useInsertionEffect",
	"useLayoutEffect",
	"useMemo",
	"useOptimistic",
	"useReducer",
	"useRef",
	"useState",
	"useSyncExternalStore",
	"useTransition"
];
/**
* Catch all identifiers that begin with "use" followed by an uppercase Latin
* character to exclude identifiers like "user".
* @param name The name of the identifier to check.
* @see https://github.com/facebook/react/blob/1d6c8168db1d82713202e842df3167787ffa00ed/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts#L16
*/
function isReactHookName(name) {
	return name === "use" || /^use[A-Z0-9]/.test(name);
}

//#endregion
//#region src/hook/hook-is.ts
/**
* Determines if a function node is a React Hook based on its name.
* @param node The function node to check
* @returns True if the function is a React Hook, false otherwise
*/
function isReactHook(node) {
	if (node == null) return false;
	const id = AST.getFunctionId(node);
	return id?.name != null && isReactHookName(id.name);
}
/**
* Check if the given node is a React Hook call by its name.
* @param node The node to check.
* @returns `true` if the node is a React Hook call, `false` otherwise.
*/
function isReactHookCall(node) {
	if (node == null) return false;
	if (node.type !== AST_NODE_TYPES.CallExpression) return false;
	if (node.callee.type === AST_NODE_TYPES.Identifier) return isReactHookName(node.callee.name);
	if (node.callee.type === AST_NODE_TYPES.MemberExpression) return node.callee.property.type === AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
	return false;
}
/**
* Checks if a node is a call to a specific React hook.
* Returns a function that accepts a hook name to check against.
* @param node The AST node to check
* @returns A function that takes a hook name and returns boolean
*/
function isReactHookCallWithName(node) {
	if (node == null || node.type !== AST_NODE_TYPES.CallExpression) return constFalse;
	return (name) => {
		switch (node.callee.type) {
			case AST_NODE_TYPES.Identifier: return node.callee.name === name;
			case AST_NODE_TYPES.MemberExpression: return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name;
			default: return false;
		}
	};
}
/**
* Checks if a node is a call to a specific React hook or one of its aliases.
* @param name The primary hook name to check
* @param alias Optional array of alias names to also accept
* @returns Function that checks if a node matches the hook name or aliases
*/
function isReactHookCallWithNameAlias(name, alias = []) {
	return (node) => {
		switch (true) {
			case node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === name: return true;
			case node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object: return true;
			default: return alias.some(isReactHookCallWithName(node));
		}
	};
}
/**
* Detects useEffect calls and variations (useLayoutEffect, etc.) using regex pattern.
* @param node The AST node to check
* @returns True if the node is a useEffect-like call
*/
function isUseEffectLikeCall(node) {
	if (node == null) return false;
	if (node.type !== AST_NODE_TYPES.CallExpression) return false;
	switch (node.callee.type) {
		case AST_NODE_TYPES.Identifier: return /^use\w*Effect$/u.test(node.callee.name);
		case AST_NODE_TYPES.MemberExpression: return node.callee.property.type === AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
		default: return false;
	}
}
const isUseCall = flip(isReactHookCallWithName)("use");
const isUseActionStateCall = flip(isReactHookCallWithName)("useActionState");
const isUseCallbackCall = flip(isReactHookCallWithName)("useCallback");
const isUseContextCall = flip(isReactHookCallWithName)("useContext");
const isUseDebugValueCall = flip(isReactHookCallWithName)("useDebugValue");
const isUseDeferredValueCall = flip(isReactHookCallWithName)("useDeferredValue");
const isUseEffectCall = flip(isReactHookCallWithName)("useEffect");
const isUseFormStatusCall = flip(isReactHookCallWithName)("useFormStatus");
const isUseIdCall = flip(isReactHookCallWithName)("useId");
const isUseImperativeHandleCall = flip(isReactHookCallWithName)("useImperativeHandle");
const isUseInsertionEffectCall = flip(isReactHookCallWithName)("useInsertionEffect");
const isUseLayoutEffectCall = flip(isReactHookCallWithName)("useLayoutEffect");
const isUseMemoCall = flip(isReactHookCallWithName)("useMemo");
const isUseOptimisticCall = flip(isReactHookCallWithName)("useOptimistic");
const isUseReducerCall = flip(isReactHookCallWithName)("useReducer");
const isUseRefCall = flip(isReactHookCallWithName)("useRef");
const isUseStateCall = flip(isReactHookCallWithName)("useState");
const isUseSyncExternalStoreCall = flip(isReactHookCallWithName)("useSyncExternalStore");
const isUseTransitionCall = flip(isReactHookCallWithName)("useTransition");

//#endregion
//#region src/hook/hook-collector.ts
function useHookCollector() {
	const hooks = /* @__PURE__ */ new Map();
	const functionEntries = [];
	const onFunctionEnter = (node) => {
		const id = AST.getFunctionId(node);
		const key = getId();
		const name = id?.name;
		if (name != null && isReactHookName(name)) {
			functionEntries.push({
				key,
				node,
				isHook: true
			});
			hooks.set(key, {
				id,
				key,
				kind: "function",
				name,
				node,
				flag: 0n,
				hint: 0n,
				hookCalls: []
			});
			return;
		}
		functionEntries.push({
			key,
			node,
			isHook: false
		});
	};
	const onFunctionExit = () => {
		functionEntries.pop();
	};
	return {
		ctx: { getAllHooks(node) {
			return hooks;
		} },
		listeners: {
			":function[type]": onFunctionEnter,
			":function[type]:exit": onFunctionExit,
			"CallExpression[type]"(node) {
				if (!isReactHookCall(node)) return;
				const fEntry = functionEntries.at(-1);
				if (fEntry?.key == null) return;
				const hook = hooks.get(fEntry.key);
				if (hook == null) return;
				hook.hookCalls.push(node);
			}
		}
	};
}

//#endregion
//#region src/hook/hook-id.ts
function isReactHookId(id) {
	switch (id.type) {
		case AST_NODE_TYPES.Identifier: return isReactHookName(id.name);
		case AST_NODE_TYPES.MemberExpression: return "name" in id.property && isReactHookName(id.property.name);
		default: return false;
	}
}

//#endregion
//#region src/hook/hook-parts.ts
function isFunctionOfUseEffectSetup(node) {
	if (node == null) return false;
	return node.parent?.type === AST_NODE_TYPES.CallExpression && node.parent.arguments.at(0) === node && isUseEffectLikeCall(node.parent);
}
function isFunctionOfUseEffectCleanup(node) {
	if (node == null) return false;
	const pReturn = AST.findParentNode(node, AST.is(AST_NODE_TYPES.ReturnStatement));
	const pFunction = AST.findParentNode(node, AST.isFunction);
	const pFunctionOfReturn = AST.findParentNode(pReturn, AST.isFunction);
	if (pFunction !== pFunctionOfReturn) return false;
	return isFunctionOfUseEffectSetup(pFunction);
}

//#endregion
//#region src/jsx/jsx-stringify.ts
/**
* Incomplete but sufficient stringification of JSX nodes for common use cases
*
* @param node - JSX node from TypeScript ESTree
* @returns String representation of the JSX node
*/
function stringifyJsx(node) {
	switch (node.type) {
		case AST_NODE_TYPES.JSXIdentifier: return node.name;
		case AST_NODE_TYPES.JSXNamespacedName: return `${node.namespace.name}:${node.name.name}`;
		case AST_NODE_TYPES.JSXMemberExpression: return `${stringifyJsx(node.object)}.${stringifyJsx(node.property)}`;
		case AST_NODE_TYPES.JSXText: return node.value;
		case AST_NODE_TYPES.JSXOpeningElement: return `<${stringifyJsx(node.name)}>`;
		case AST_NODE_TYPES.JSXClosingElement: return `</${stringifyJsx(node.name)}>`;
		case AST_NODE_TYPES.JSXOpeningFragment: return "<>";
		case AST_NODE_TYPES.JSXClosingFragment: return "</>";
	}
}

//#endregion
//#region src/jsx/jsx-attribute-name.ts
/**
* Get the stringified name of a JSX attribute
* @param context The ESLint rule context
* @param node The JSX attribute node
* @returns The name of the attribute
*/
function getAttributeName(context, node) {
	return stringifyJsx(node.name);
}

//#endregion
//#region src/jsx/jsx-attribute.ts
function getAttribute(context, attributes, initialScope) {
	return (name) => {
		return attributes.findLast((attr) => {
			if (attr.type === AST_NODE_TYPES.JSXAttribute) return getAttributeName(context, attr) === name;
			if (initialScope == null) return false;
			switch (attr.argument.type) {
				case AST_NODE_TYPES.Identifier: {
					const variable = findVariable(attr.argument.name, initialScope);
					const variableNode = getVariableDefinitionNode(variable, 0);
					if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) return findProperty(name, variableNode.properties, initialScope) != null;
					return false;
				}
				case AST_NODE_TYPES.ObjectExpression: return findProperty(name, attr.argument.properties, initialScope) != null;
			}
			return false;
		});
	};
}

//#endregion
//#region src/jsx/jsx-attribute-value.ts
function resolveAttributeValue(context, attribute) {
	const initialScope = context.sourceCode.getScope(attribute);
	function handleJsxAttribute(node) {
		if (node.value == null) return {
			kind: "boolean",
			toStatic() {
				return true;
			}
		};
		switch (node.value.type) {
			case AST_NODE_TYPES.Literal: {
				const staticValue = node.value.value;
				return {
					kind: "literal",
					node: node.value,
					toStatic() {
						return staticValue;
					}
				};
			}
			case AST_NODE_TYPES.JSXExpressionContainer: {
				const expr = node.value.expression;
				return {
					kind: "expression",
					node: expr,
					toStatic() {
						return getStaticValue(expr, initialScope)?.value;
					}
				};
			}
			case AST_NODE_TYPES.JSXElement: return {
				kind: "element",
				node: node.value,
				toStatic() {
					return unit;
				}
			};
			case AST_NODE_TYPES.JSXSpreadChild: return {
				kind: "spreadChild",
				node: node.value.expression,
				toStatic() {
					return unit;
				}
			};
		}
	}
	function handleJsxSpreadAttribute(node) {
		return {
			kind: "spreadProps",
			node: node.argument,
			toStatic(name) {
				if (name == null) return unit;
				return match(getStaticValue(node.argument, initialScope)?.value).with({ [name]: P.select(P.any) }, identity).otherwise(() => unit);
			}
		};
	}
	switch (attribute.type) {
		case AST_NODE_TYPES.JSXAttribute: return handleJsxAttribute(attribute);
		case AST_NODE_TYPES.JSXSpreadAttribute: return handleJsxSpreadAttribute(attribute);
	}
}

//#endregion
//#region src/jsx/jsx-config.ts
const JsxEmit = {
	None: 0,
	Preserve: 1,
	React: 2,
	ReactNative: 3,
	ReactJSX: 4,
	ReactJSXDev: 5
};
/**
* Get JsxConfig from the rule context by reading compiler options.
* @param context The RuleContext.
* @returns JsxConfig derived from compiler options.
*/
function getJsxConfigFromContext(context) {
	const options = context.sourceCode.parserServices?.program?.getCompilerOptions() ?? {};
	return {
		jsx: options.jsx ?? JsxEmit.ReactJSX,
		jsxFactory: options.jsxFactory ?? "React.createElement",
		jsxFragmentFactory: options.jsxFragmentFactory ?? "React.Fragment",
		jsxImportSource: options.jsxImportSource ?? "react"
	};
}
const cache = /* @__PURE__ */ new WeakMap();
/**
* Get JsxConfig from pragma comments (annotations) in the source code.
* @param context The RuleContext.
* @returns JsxConfig derived from pragma comments.
*/
function getJsxConfigFromAnnotation(context) {
	return getOrElseUpdate(cache, context.sourceCode, () => {
		const options = {};
		if (!context.sourceCode.text.includes("@jsx")) return options;
		let jsx, jsxFrag, jsxRuntime, jsxImportSource;
		for (const comment of context.sourceCode.getAllComments().reverse()) {
			const value = comment.value;
			jsx ??= value.match(RE_ANNOTATION_JSX)?.[1];
			jsxFrag ??= value.match(RE_ANNOTATION_JSX_FRAG)?.[1];
			jsxRuntime ??= value.match(RE_ANNOTATION_JSX_RUNTIME)?.[1];
			jsxImportSource ??= value.match(RE_ANNOTATION_JSX_IMPORT_SOURCE)?.[1];
		}
		if (jsx != null) options.jsxFactory = jsx;
		if (jsxFrag != null) options.jsxFragmentFactory = jsxFrag;
		if (jsxRuntime != null) options.jsx = jsxRuntime === "classic" ? JsxEmit.React : JsxEmit.ReactJSX;
		if (jsxImportSource != null) options.jsxImportSource = jsxImportSource;
		return options;
	});
}

//#endregion
//#region src/jsx/jsx-detection.ts
/**
* Flags to control JSX detection behavior:
* - Skip* flags: Ignore specific node types when detecting JSX
* - Strict* flags: Enforce stricter rules for container types
*/
const JSXDetectionHint = {
	None: 0n,
	SkipUndefined: 1n << 0n,
	SkipNullLiteral: 1n << 1n,
	SkipBooleanLiteral: 1n << 2n,
	SkipStringLiteral: 1n << 3n,
	SkipNumberLiteral: 1n << 4n,
	SkipBigIntLiteral: 1n << 5n,
	SkipEmptyArray: 1n << 6n,
	SkipCreateElement: 1n << 7n,
	StrictArray: 1n << 8n,
	StrictLogical: 1n << 9n,
	StrictConditional: 1n << 10n
};
/**
* Default JSX detection configuration
* Skips undefined and boolean literals (common in React)
*/
const DEFAULT_JSX_DETECTION_HINT = 0n | JSXDetectionHint.SkipUndefined | JSXDetectionHint.SkipBooleanLiteral;
/**
* Checks if a node is a `JSXText` or a `Literal` node
* @param node The AST node to check
* @returns `true` if the node is a `JSXText` or a `Literal` node
*/
function isJsxText(node) {
	if (node == null) return false;
	return node.type === AST_NODE_TYPES.JSXText || node.type === AST_NODE_TYPES.Literal;
}
/**
* Determines if a node represents JSX-like content based on heuristics
* Supports configuration through hint flags to customize detection behavior
*
* @param code The source code with scope lookup capability
* @param code.getScope The function to get the scope of a node
* @param node The AST node to analyze
* @param hint The configuration flags to adjust detection behavior
* @returns boolean Whether the node is considered JSX-like
*/
function isJsxLike(code, node, hint = DEFAULT_JSX_DETECTION_HINT) {
	if (node == null) return false;
	if (AST.isJSX(node)) return true;
	switch (node.type) {
		case AST_NODE_TYPES.Literal:
			switch (typeof node.value) {
				case "boolean": return !(hint & JSXDetectionHint.SkipBooleanLiteral);
				case "string": return !(hint & JSXDetectionHint.SkipStringLiteral);
				case "number": return !(hint & JSXDetectionHint.SkipNumberLiteral);
				case "bigint": return !(hint & JSXDetectionHint.SkipBigIntLiteral);
			}
			if (node.value == null) return !(hint & JSXDetectionHint.SkipNullLiteral);
			return false;
		case AST_NODE_TYPES.TemplateLiteral: return !(hint & JSXDetectionHint.SkipStringLiteral);
		case AST_NODE_TYPES.ArrayExpression:
			if (node.elements.length === 0) return !(hint & JSXDetectionHint.SkipEmptyArray);
			if (hint & JSXDetectionHint.StrictArray) return node.elements.every((n) => isJsxLike(code, n, hint));
			return node.elements.some((n) => isJsxLike(code, n, hint));
		case AST_NODE_TYPES.LogicalExpression:
			if (hint & JSXDetectionHint.StrictLogical) return isJsxLike(code, node.left, hint) && isJsxLike(code, node.right, hint);
			return isJsxLike(code, node.left, hint) || isJsxLike(code, node.right, hint);
		case AST_NODE_TYPES.ConditionalExpression: {
			function leftHasJSX(node$1) {
				if (Array.isArray(node$1.consequent)) {
					if (node$1.consequent.length === 0) return !(hint & JSXDetectionHint.SkipEmptyArray);
					if (hint & JSXDetectionHint.StrictArray) return node$1.consequent.every((n) => isJsxLike(code, n, hint));
					return node$1.consequent.some((n) => isJsxLike(code, n, hint));
				}
				return isJsxLike(code, node$1.consequent, hint);
			}
			function rightHasJSX(node$1) {
				return isJsxLike(code, node$1.alternate, hint);
			}
			if (hint & JSXDetectionHint.StrictConditional) return leftHasJSX(node) && rightHasJSX(node);
			return leftHasJSX(node) || rightHasJSX(node);
		}
		case AST_NODE_TYPES.SequenceExpression: {
			const exp = node.expressions.at(-1);
			return isJsxLike(code, exp, hint);
		}
		case AST_NODE_TYPES.CallExpression:
			if (hint & JSXDetectionHint.SkipCreateElement) return false;
			switch (node.callee.type) {
				case AST_NODE_TYPES.Identifier: return node.callee.name === "createElement";
				case AST_NODE_TYPES.MemberExpression: return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
			}
			return false;
		case AST_NODE_TYPES.Identifier: {
			const { name } = node;
			if (name === "undefined") return !(hint & JSXDetectionHint.SkipUndefined);
			if (AST.isJSXTagNameExpression(node)) return true;
			const variable = findVariable(name, code.getScope(node));
			const variableNode = variable && getVariableDefinitionNode(variable, 0);
			return !!variableNode && isJsxLike(code, variableNode, hint);
		}
	}
	return false;
}

//#endregion
//#region src/jsx/jsx-element-type.ts
/**
* Extracts the element type name from a JSX element or fragment
* For JSX elements, returns the stringified name (e.g., "div", "Button", "React.Fragment")
* For JSX fragments, returns an empty string
*
* @param context - ESLint rule context
* @param node - JSX element or fragment node
* @returns String representation of the element type
*/
function getElementType(context, node) {
	if (node.type === AST_NODE_TYPES.JSXFragment) return "";
	return stringifyJsx(node.openingElement.name);
}

//#endregion
//#region src/jsx/jsx-element-is.ts
/**
* Determines if a JSX element is a host element
* Host elements in React start with lowercase letters (e.g., div, span)
*
* @param context - ESLint rule context
* @param node - AST node to check
* @returns boolean indicating if the element is a host element
*/
function isHostElement(context, node) {
	return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && /^[a-z]/u.test(node.openingElement.name.name);
}
/**
* Determines if a JSX element is a React Fragment
* Fragments can be imported from React and used like <Fragment> or <React.Fragment>
*
* @param context - ESLint rule context
* @param node - AST node to check
* @returns boolean indicating if the element is a Fragment with type narrowing
*/
function isFragmentElement(context, node) {
	if (node.type !== AST_NODE_TYPES.JSXElement) return false;
	return getElementType(context, node).split(".").at(-1) === "Fragment";
}

//#endregion
//#region src/jsx/jsx-has.ts
/**
* Checks if a JSX element has a specific attribute
*
* @param context - ESLint rule context
* @param name - Name of the attribute to check for
* @param attributes - List of JSX attributes from opening element
* @param initialScope - Optional scope for resolving variables in spread attributes
* @returns boolean indicating whether the attribute exists
*/
function hasAttribute(context, name, attributes, initialScope) {
	return getAttribute(context, attributes, initialScope)(name) != null;
}
/**
* Checks if a JSX element has at least one of the specified attributes
*
* @param context - ESLint rule context
* @param names - Array of attribute names to check for
* @param attributes - List of JSX attributes from opening element
* @param initialScope - Optional scope for resolving variables in spread attributes
* @returns boolean indicating whether any of the attributes exist
*/
function hasAnyAttribute(context, names, attributes, initialScope) {
	return names.some((n) => hasAttribute(context, n, attributes, initialScope));
}
/**
* Checks if a JSX element has all of the specified attributes
*
* @param context - ESLint rule context
* @param names - Array of attribute names to check for
* @param attributes - List of JSX attributes from opening element
* @param initialScope - Optional scope for resolving variables in spread attributes
* @returns boolean indicating whether all of the attributes exist
*/
function hasEveryAttribute(context, names, attributes, initialScope) {
	return names.every((n) => hasAttribute(context, n, attributes, initialScope));
}

//#endregion
//#region src/jsx/jsx-hierarchy.ts
/**
* Traverses up the AST to find a parent JSX attribute node that matches a given test
*
* @param node - The starting AST node
* @param test - Optional predicate function to test if the attribute meets criteria
*               Defaults to always returning true (matches any attribute)
* @returns The first matching JSX attribute node found when traversing upwards, or undefined
*/
function findParentAttribute(node, test = constTrue) {
	const guard = (node$1) => {
		return node$1.type === AST_NODE_TYPES.JSXAttribute && test(node$1);
	};
	return AST.findParentNode(node, guard);
}

//#endregion
//#region src/component/component-detection-hint.ts
/**
* Hints for component collector
*/
const ComponentDetectionHint = {
	...JSXDetectionHint,
	SkipMemo: 1n << 64n,
	SkipForwardRef: 1n << 65n,
	SkipArrayMapArgument: 1n << 66n,
	SkipObjectMethod: 1n << 67n,
	SkipClassMethod: 1n << 68n,
	SkipClassProperty: 1n << 69n
};
/**
* Default component detection hint
*/
const DEFAULT_COMPONENT_DETECTION_HINT = 0n | ComponentDetectionHint.SkipBooleanLiteral | ComponentDetectionHint.SkipEmptyArray | ComponentDetectionHint.SkipArrayMapArgument | ComponentDetectionHint.SkipNumberLiteral | ComponentDetectionHint.SkipStringLiteral | ComponentDetectionHint.SkipUndefined | ComponentDetectionHint.StrictArray | ComponentDetectionHint.StrictConditional | ComponentDetectionHint.StrictLogical;

//#endregion
//#region src/component/component-is.ts
/**
* Check if a node is a React class component
* @param node The AST node to check
* @returns `true` if the node is a class component, `false` otherwise
*/
function isClassComponent(node) {
	if ("superClass" in node && node.superClass != null) {
		const re = /^(?:Pure)?Component$/u;
		switch (true) {
			case node.superClass.type === AST_NODE_TYPES.Identifier: return re.test(node.superClass.name);
			case node.superClass.type === AST_NODE_TYPES.MemberExpression && node.superClass.property.type === AST_NODE_TYPES.Identifier: return re.test(node.superClass.property.name);
		}
	}
	return false;
}
/**
* Check if a node is a React PureComponent
* @param node The AST node to check
* @returns `true` if the node is a pure component, `false` otherwise
*/
function isPureComponent(node) {
	if ("superClass" in node && node.superClass != null) {
		const re = /^PureComponent$/u;
		switch (true) {
			case node.superClass.type === AST_NODE_TYPES.Identifier: return re.test(node.superClass.name);
			case node.superClass.type === AST_NODE_TYPES.MemberExpression && node.superClass.property.type === AST_NODE_TYPES.Identifier: return re.test(node.superClass.property.name);
		}
	}
	return false;
}

//#endregion
//#region src/component/component-render-method.ts
/**
* Check whether given node is a render method of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   renderHeader = () => <div />;
*   renderFooter = () => <div />;
* }
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isRenderMethodLike(node) {
	return AST.isMethodOrProperty(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name.startsWith("render") && node.parent.parent.type === AST_NODE_TYPES.ClassDeclaration;
}

//#endregion
//#region src/component/component-definition.ts
/**
* Function pattern matchers for different contexts
*/
const functionPatterns = {
	classMethod: {
		type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
		parent: AST_NODE_TYPES.MethodDefinition
	},
	classProperty: {
		type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
		parent: AST_NODE_TYPES.Property
	},
	objectMethod: {
		type: P.union(AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression),
		parent: {
			type: AST_NODE_TYPES.Property,
			parent: { type: AST_NODE_TYPES.ObjectExpression }
		}
	}
};
/**
* Check whether given node is a function of a render method of a class component
* @example
* ```tsx
* class Component extends React.Component {
*   renderHeader = () => <div />;
*   renderFooter = () => <div />;
* }
* ```
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isFunctionOfRenderMethod(node) {
	return isRenderMethodLike(node.parent) && isClassComponent(node.parent.parent.parent);
}
/**
* Checks if a function node should be excluded based on detection hints
* @param node The function node to check
* @param hint Component detection hints as bit flags
* @returns `true` if the function should be excluded, `false` otherwise
*/
function shouldExcludeBasedOnHint(node, hint) {
	if (hint & ComponentDetectionHint.SkipObjectMethod && isMatching(functionPatterns.objectMethod)(node)) return true;
	if (hint & ComponentDetectionHint.SkipClassMethod && isMatching(functionPatterns.classMethod)(node)) return true;
	if (hint & ComponentDetectionHint.SkipClassProperty && isMatching(functionPatterns.classProperty)(node)) return true;
	if (hint & ComponentDetectionHint.SkipArrayMapArgument && AST.isArrayMapCall(node.parent)) return true;
	return false;
}
/**
* Determines if a function node represents a valid React component definition
* @param context The rule context
* @param node The function node to check
* @param hint Component detection hints as bit flags
* @returns `true` if the node is a valid component definition, `false` otherwise
*/
function isComponentDefinition(context, node, hint) {
	if (isChildrenOfCreateElement(context, node) || isFunctionOfRenderMethod(node)) return false;
	if (shouldExcludeBasedOnHint(node, hint)) return false;
	const significantParent = AST.findParentNode(node, AST.isOneOf([
		AST_NODE_TYPES.JSXExpressionContainer,
		AST_NODE_TYPES.ArrowFunctionExpression,
		AST_NODE_TYPES.FunctionExpression,
		AST_NODE_TYPES.Property,
		AST_NODE_TYPES.ClassBody
	]));
	return significantParent == null || significantParent.type !== AST_NODE_TYPES.JSXExpressionContainer;
}

//#endregion
//#region src/utils/get-instance-id.ts
/**
* Gets the identifier node of an instance based on AST node relationships.
* Used for tracking where hooks or components are being assigned in the code.
* @param node The current AST node to evaluate
* @param prev The previous AST node in the traversal (used for context)
* @internal
*/
function getInstanceId(node, prev) {
	switch (true) {
		case node.type === AST_NODE_TYPES.VariableDeclarator && node.init === prev: return node.id;
		case node.type === AST_NODE_TYPES.AssignmentExpression && node.right === prev: return node.left;
		case node.type === AST_NODE_TYPES.PropertyDefinition && node.value === prev: return node.key;
		case node.type === AST_NODE_TYPES.BlockStatement || node.type === AST_NODE_TYPES.Program || node.parent === node: return unit;
		default: return getInstanceId(node.parent, node);
	}
}

//#endregion
//#region src/utils/is-from-react.ts
/**
* Get the arguments of a require expression
* @param node The node to match
* @returns The require expression arguments or undefined if the node is not a require expression
*/
function getRequireExpressionArguments(node) {
	return match(node).with({
		type: AST_NODE_TYPES.CallExpression,
		arguments: P.select(),
		callee: {
			type: AST_NODE_TYPES.Identifier,
			name: "require"
		}
	}, identity).with({
		type: AST_NODE_TYPES.MemberExpression,
		object: P.select()
	}, getRequireExpressionArguments).otherwise(() => null);
}
/**
* Check if an identifier name is initialized from react
* @param name The top-level identifier's name
* @param importSource The import source to check against
* @param initialScope Initial scope to search for the identifier
* @returns Whether the identifier name is initialized from react
* @internal
*/
function isInitializedFromReact(name, importSource, initialScope) {
	if (name.toLowerCase() === "react") return true;
	const latestDef = findVariable(name, initialScope)?.defs.at(-1);
	if (latestDef == null) return false;
	const { node, parent } = latestDef;
	if (node.type === AST_NODE_TYPES.VariableDeclarator && node.init != null) {
		const { init } = node;
		if (init.type === AST_NODE_TYPES.MemberExpression && init.object.type === AST_NODE_TYPES.Identifier) return isInitializedFromReact(init.object.name, importSource, initialScope);
		if (init.type === AST_NODE_TYPES.Identifier) return isInitializedFromReact(init.name, importSource, initialScope);
		const arg0 = getRequireExpressionArguments(init)?.[0];
		if (arg0 == null || !AST.isLiteral(arg0, "string")) return false;
		return arg0.value === importSource || arg0.value.startsWith(`${importSource}/`);
	}
	return parent?.type === AST_NODE_TYPES.ImportDeclaration && parent.source.value === importSource;
}

//#endregion
//#region src/utils/is-instance-id-equal.ts
/** @internal */
function isInstanceIdEqual(context, a, b) {
	return AST.isNodeEqual(a, b) || isNodeValueEqual(a, b, [context.sourceCode.getScope(a), context.sourceCode.getScope(b)]);
}

//#endregion
//#region src/component/component-wrapper.ts
/**
* Check if the node is a call expression for a component wrapper
* @param context The ESLint rule context
* @param node The node to check
* @returns `true` if the node is a call expression for a component wrapper
*/
function isComponentWrapperCall(context, node) {
	if (node.type !== AST_NODE_TYPES.CallExpression) return false;
	return isMemoCall(context, node) || isForwardRefCall(context, node);
}
/**
* Check if the node is a call expression for a component wrapper loosely
* @param context The ESLint rule context
* @param node The node to check
* @returns `true` if the node is a call expression for a component wrapper loosely
*/
function isComponentWrapperCallLoose(context, node) {
	if (node.type !== AST_NODE_TYPES.CallExpression) return false;
	return isComponentWrapperCall(context, node) || isUseCallbackCall(node);
}

//#endregion
//#region src/component/component-id.ts
function getFunctionComponentId(context, node) {
	const functionId = AST.getFunctionId(node);
	if (functionId != null) return functionId;
	const { parent } = node;
	if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === AST_NODE_TYPES.Identifier) return parent.parent.id;
	if (parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent) && parent.parent.type === AST_NODE_TYPES.CallExpression && isComponentWrapperCallLoose(context, parent.parent) && parent.parent.parent.type === AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === AST_NODE_TYPES.Identifier) return parent.parent.parent.id;
	return unit;
}

//#endregion
//#region src/component/component-flag.ts
const ComponentFlag = {
	None: 0n,
	PureComponent: 1n << 0n,
	CreateElement: 1n << 1n,
	Memo: 1n << 2n,
	ForwardRef: 1n << 3n,
	Async: 1n << 4n
};

//#endregion
//#region src/component/component-init-path.ts
function getComponentFlagFromInitPath(initPath) {
	let flag = ComponentFlag.None;
	if (initPath != null && AST.hasCallInFunctionInitPath("memo", initPath)) flag |= ComponentFlag.Memo;
	if (initPath != null && AST.hasCallInFunctionInitPath("forwardRef", initPath)) flag |= ComponentFlag.ForwardRef;
	return flag;
}

//#endregion
//#region src/component/component-name.ts
function isComponentName(name) {
	return RE_COMPONENT_NAME.test(name);
}
function isComponentNameLoose(name) {
	return RE_COMPONENT_NAME_LOOSE.test(name);
}
function getComponentNameFromId(id) {
	if (id == null) return unit;
	return Array.isArray(id) ? id.map((n) => n.name).join(".") : id.name;
}
function hasNoneOrLooseComponentName(context, fn) {
	const id = getFunctionComponentId(context, fn);
	if (id == null) return true;
	const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
	return name != null && isComponentNameLoose(name);
}

//#endregion
//#region src/component/component-collector.ts
/**
* Get a ctx and listeners for the rule to collect function components
* @param context The ESLint rule context
* @param options The options to use
* @returns The component collector
*/
function useComponentCollector(context, options = {}) {
	const { collectDisplayName = false, collectHookCalls = false, hint = DEFAULT_COMPONENT_DETECTION_HINT } = options;
	const components = /* @__PURE__ */ new Map();
	const functionEntries = [];
	const getCurrentEntry = () => functionEntries.at(-1);
	const onFunctionEnter = (node) => {
		const key = getId();
		functionEntries.push({
			key,
			node,
			hookCalls: [],
			isComponent: false
		});
	};
	const onFunctionExit = () => {
		const entry = functionEntries.at(-1);
		if (entry == null) return;
		if (!entry.isComponent) return functionEntries.pop();
		const rets = AST.getNestedReturnStatements(entry.node.body);
		for (let i = rets.length - 1; i >= 0; i--) {
			const ret = rets[i];
			if (ret == null) continue;
			if (context.sourceCode.getScope(ret).block === entry.node && ret.argument != null && !isJsxLike(context.sourceCode, ret.argument, hint)) {
				components.delete(entry.key);
				break;
			}
		}
		return functionEntries.pop();
	};
	const ctx = {
		getAllComponents(node) {
			return components;
		},
		getCurrentEntries() {
			return [...functionEntries];
		},
		getCurrentEntry
	};
	const listeners = {
		":function[type]": onFunctionEnter,
		":function[type]:exit": onFunctionExit,
		"ArrowFunctionExpression[body.type!='BlockStatement']"() {
			const entry = getCurrentEntry();
			if (entry == null) return;
			const { body } = entry.node;
			if (!(hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, body, hint) && isComponentDefinition(context, entry.node, hint))) return;
			const initPath = AST.getFunctionInitPath(entry.node);
			const id = getFunctionComponentId(context, entry.node);
			const name = getComponentNameFromId(id);
			const key = getId();
			components.set(key, {
				id,
				key,
				kind: "function",
				name,
				node: entry.node,
				displayName: unit,
				flag: getComponentFlagFromInitPath(initPath),
				hint,
				hookCalls: entry.hookCalls,
				initPath
			});
		},
		...collectDisplayName ? { [AST.SEL_DISPLAY_NAME_ASSIGNMENT_EXPRESSION](node) {
			const { left, right } = node;
			if (left.type !== AST_NODE_TYPES.MemberExpression) return;
			const componentName = left.object.type === AST_NODE_TYPES.Identifier ? left.object.name : unit;
			const component = [...components.values()].findLast(({ name }) => name != null && name === componentName);
			if (component == null) return;
			component.displayName = right;
		} } : {},
		...collectHookCalls ? { "CallExpression[type]:exit"(node) {
			if (!isReactHookCall(node)) return;
			const entry = getCurrentEntry();
			if (entry == null) return;
			entry.hookCalls.push(node);
		} } : {},
		"ReturnStatement[type]"(node) {
			const entry = getCurrentEntry();
			if (entry == null) return;
			if (!(hasNoneOrLooseComponentName(context, entry.node) && isJsxLike(context.sourceCode, node.argument, hint) && isComponentDefinition(context, entry.node, hint))) return;
			entry.isComponent = true;
			const initPath = AST.getFunctionInitPath(entry.node);
			const id = getFunctionComponentId(context, entry.node);
			const name = getComponentNameFromId(id);
			components.set(entry.key, {
				id,
				key: entry.key,
				kind: "function",
				name,
				node: entry.node,
				displayName: unit,
				flag: getComponentFlagFromInitPath(initPath),
				hint,
				hookCalls: entry.hookCalls,
				initPath
			});
		}
	};
	return {
		ctx,
		listeners
	};
}

//#endregion
//#region src/component/component-collector-legacy.ts
/**
* Get a ctx and listeners object for the rule to collect class components
* @returns The context and listeners for the rule
*/
function useComponentCollectorLegacy() {
	const components = /* @__PURE__ */ new Map();
	const ctx = { getAllComponents(node) {
		return components;
	} };
	const collect = (node) => {
		if (!isClassComponent(node)) return;
		const id = AST.getClassId(node);
		const key = getId();
		const flag = isPureComponent(node) ? ComponentFlag.PureComponent : ComponentFlag.None;
		components.set(key, {
			id,
			key,
			kind: "class",
			name: id?.name,
			node,
			displayName: unit,
			flag,
			hint: 0n,
			methods: []
		});
	};
	return {
		ctx,
		listeners: {
			"ClassDeclaration[type]": collect,
			"ClassExpression[type]": collect
		}
	};
}

//#endregion
//#region src/component/component-method.ts
/**
* Create a lifecycle method checker function
* @param methodName The lifecycle method name
* @param isStatic Whether the method is static
*/
function createLifecycleChecker(methodName, isStatic) {
	return function(node) {
		return AST.isMethodOrProperty(node) && node.static === isStatic && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === methodName;
	};
}
const isRender = createLifecycleChecker("render", false);
const isComponentDidCatch = createLifecycleChecker("componentDidCatch", false);
const isComponentDidMount = createLifecycleChecker("componentDidMount", false);
const isComponentDidUpdate = createLifecycleChecker("componentDidUpdate", false);
const isComponentWillMount = createLifecycleChecker("componentWillMount", false);
const isComponentWillReceiveProps = createLifecycleChecker("componentWillReceiveProps", false);
const isComponentWillUnmount = createLifecycleChecker("componentWillUnmount", false);
const isComponentWillUpdate = createLifecycleChecker("componentWillUpdate", false);
const isGetChildContext = createLifecycleChecker("getChildContext", false);
const isGetInitialState = createLifecycleChecker("getInitialState", false);
const isGetSnapshotBeforeUpdate = createLifecycleChecker("getSnapshotBeforeUpdate", false);
const isShouldComponentUpdate = createLifecycleChecker("shouldComponentUpdate", false);
const isUnsafeComponentWillMount = createLifecycleChecker("UNSAFE_componentWillMount", false);
const isUnsafeComponentWillReceiveProps = createLifecycleChecker("UNSAFE_componentWillReceiveProps", false);
const isUnsafeComponentWillUpdate = createLifecycleChecker("UNSAFE_componentWillUpdate", false);
const isGetDefaultProps = createLifecycleChecker("getDefaultProps", true);
const isGetDerivedStateFromProps = createLifecycleChecker("getDerivedStateFromProps", true);
const isGetDerivedStateFromError = createLifecycleChecker("getDerivedStateFromError", true);

//#endregion
//#region src/component/component-method-parts.ts
function isFunctionOfComponentDidMount(node) {
	return AST.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isFunctionOfComponentWillUnmount(node) {
	return AST.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}

//#endregion
//#region src/component/component-phase.ts
const ComponentPhaseRelevance = birecord({
	mount: "unmount",
	setup: "cleanup"
});

//#endregion
//#region src/component/component-phase-helpers.ts
const isInversePhase = dual(2, (a, b) => ComponentPhaseRelevance.get(a) === b);
function getPhaseKindOfFunction(node) {
	return match(node).when(isFunctionOfUseEffectSetup, () => "setup").when(isFunctionOfUseEffectCleanup, () => "cleanup").when(isFunctionOfComponentDidMount, () => "mount").when(isFunctionOfComponentWillUnmount, () => "unmount").otherwise(() => null);
}

//#endregion
//#region src/component/component-render-prop.ts
/**
* Unsafe check whether given node is a render function
* ```tsx
* const renderRow = () => <div />
* `                 ^^^^^^^^^^^^`
* _ = <Component renderRow={() => <div />} />
* `                         ^^^^^^^^^^^^^   `
* ```
* @param context The rule context
* @param node The AST node to check
* @returns `true` if node is a render function, `false` if not
*/
function isRenderFunctionLoose(context, node) {
	const { body, parent } = node;
	if (AST.getFunctionId(node)?.name.startsWith("render")) return parent.type === AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
	return isJsxLike(context.sourceCode, body, JSXDetectionHint.SkipNullLiteral | JSXDetectionHint.SkipUndefined | JSXDetectionHint.StrictLogical | JSXDetectionHint.StrictConditional);
}
/**
* Unsafe check whether given JSXAttribute is a render prop
* ```tsx
* _ = <Component renderRow={() => <div />} />
* `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
* ```
* @param context The rule context
* @param node The AST node to check
* @returns `true` if node is a render prop, `false` if not
*/
function isRenderPropLoose(context, node) {
	if (node.name.type !== AST_NODE_TYPES.JSXIdentifier) return false;
	return node.name.name.startsWith("render") && node.value?.type === AST_NODE_TYPES.JSXExpressionContainer && AST.isFunction(node.value.expression) && isRenderFunctionLoose(context, node.value.expression);
}
/**
* Unsafe check whether given node is declared directly inside a render property
* ```tsx
* const rows = { render: () => <div /> }
* `                      ^^^^^^^^^^^^^ `
* _ = <Component rows={ [{ render: () => <div /> }] } />
* `                                ^^^^^^^^^^^^^       `
*  ```
* @internal
* @param node The AST node to check
* @returns `true` if component is declared inside a render property, `false` if not
*/
function isDirectValueOfRenderPropertyLoose(node) {
	const matching = (node$1) => {
		return node$1.type === AST_NODE_TYPES.Property && node$1.key.type === AST_NODE_TYPES.Identifier && node$1.key.name.startsWith("render");
	};
	return matching(node) || node.parent != null && matching(node.parent);
}
/**
* Unsafe check whether given node is declared inside a render prop
* ```tsx
* _ = <Component renderRow={"node"} />
* `                         ^^^^^^   `
* _ = <Component rows={ [{ render: "node" }] } />
* `                                ^^^^^^       `
* ```
* @param node The AST node to check
* @returns `true` if component is declared inside a render prop, `false` if not
*/
function isDeclaredInRenderPropLoose(node) {
	if (isDirectValueOfRenderPropertyLoose(node)) return true;
	const parent = AST.findParentNode(node, AST.is(AST_NODE_TYPES.JSXExpressionContainer))?.parent;
	if (parent?.type !== AST_NODE_TYPES.JSXAttribute) return false;
	return parent.name.type === AST_NODE_TYPES.JSXIdentifier && parent.name.name.startsWith("render");
}

//#endregion
//#region src/component/component-state.ts
function isThisSetState(node) {
	const { callee } = node;
	return callee.type === AST_NODE_TYPES.MemberExpression && AST.isThisExpression(callee.object) && callee.property.type === AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}
function isAssignmentToThisState(node) {
	const { left } = node;
	return left.type === AST_NODE_TYPES.MemberExpression && AST.isThisExpression(left.object) && AST.getPropertyName(left.property) === "state";
}

//#endregion
export { ComponentDetectionHint, ComponentFlag, ComponentPhaseRelevance, DEFAULT_COMPONENT_DETECTION_HINT, DEFAULT_JSX_DETECTION_HINT, JSXDetectionHint, JsxEmit, REACT_BUILTIN_HOOK_NAMES, findParentAttribute, getAttribute, getAttributeName, getComponentFlagFromInitPath, getComponentNameFromId, getElementType, getFunctionComponentId, getInstanceId, getJsxConfigFromAnnotation, getJsxConfigFromContext, getPhaseKindOfFunction, hasAnyAttribute, hasAttribute, hasEveryAttribute, hasNoneOrLooseComponentName, isAssignmentToThisState, isCaptureOwnerStack, isCaptureOwnerStackCall, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDefinition, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentName, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUnmount, isComponentWillUpdate, isComponentWrapperCall, isComponentWrapperCallLoose, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetChildContext, isGetDefaultProps, isGetDerivedStateFromError, isGetDerivedStateFromProps, isGetInitialState, isGetSnapshotBeforeUpdate, isHostElement, isInitializedFromReact, isInstanceIdEqual, isInversePhase, isJsxLike, isJsxText, isLazy, isLazyCall, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookId, isReactHookName, isRender, isRenderFunctionLoose, isRenderMethodLike, isRenderPropLoose, isShouldComponentUpdate, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseActionStateCall, isUseCall, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectLikeCall, isUseFormStatusCall, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseOptimisticCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, resolveAttributeValue, stringifyJsx, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
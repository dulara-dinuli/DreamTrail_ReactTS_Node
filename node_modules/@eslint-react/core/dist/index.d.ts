import { TSESTree } from "@typescript-eslint/types";
import * as AST from "@eslint-react/ast";
import { unit } from "@eslint-react/eff";
import { RuleContext } from "@eslint-react/kit";
import * as birecord0 from "birecord";
import { ESLintUtils, TSESTree as TSESTree$1 } from "@typescript-eslint/utils";
import { Scope } from "@typescript-eslint/scope-manager";
import * as typescript0 from "typescript";

//#region src/component/component-children.d.ts
/**
 * Determines whether inside `createElement`'s children.
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if the node is inside createElement's children
 */
declare function isChildrenOfCreateElement(context: RuleContext, node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-detection-hint.d.ts
type ComponentDetectionHint = bigint;
/**
 * Hints for component collector
 */
declare const ComponentDetectionHint: {
  /**
   * Skip function component created by React.memo
   */
  readonly SkipMemo: bigint;
  /**
   * Skip function component created by React.forwardRef
   */
  readonly SkipForwardRef: bigint;
  /**
   * Skip function component defined as array map argument
   */
  readonly SkipArrayMapArgument: bigint;
  /**
   * Skip function component defined on object method
   */
  readonly SkipObjectMethod: bigint;
  /**
   * Skip function component defined on class method
   */
  readonly SkipClassMethod: bigint;
  /**
   * Skip function component defined on class property
   */
  readonly SkipClassProperty: bigint;
  readonly None: 0n;
  readonly SkipUndefined: bigint;
  readonly SkipNullLiteral: bigint;
  readonly SkipBooleanLiteral: bigint;
  readonly SkipStringLiteral: bigint;
  readonly SkipNumberLiteral: bigint;
  readonly SkipBigIntLiteral: bigint;
  readonly SkipEmptyArray: bigint;
  readonly SkipCreateElement: bigint;
  readonly StrictArray: bigint;
  readonly StrictLogical: bigint;
  readonly StrictConditional: bigint;
};
/**
 * Default component detection hint
 */
declare const DEFAULT_COMPONENT_DETECTION_HINT: bigint;
//#endregion
//#region src/component/component-phase.d.ts
type ComponentEffectPhaseKind = "cleanup" | "setup";
type ComponentLifecyclePhaseKind = "mount" | "unmount";
type ComponentPhaseKind = ComponentEffectPhaseKind | ComponentLifecyclePhaseKind;
declare const ComponentPhaseRelevance: birecord0.BiRecord<{
  readonly mount: "unmount";
  readonly setup: "cleanup";
}>;
//#endregion
//#region src/semantic/semantic-entry.d.ts
interface SemanticEntry {
  node: TSESTree.Node;
  phase: ComponentPhaseKind;
}
//#endregion
//#region src/semantic/semantic-node.d.ts
interface SemanticNode {
  id: unit | TSESTree.Identifier | TSESTree.Identifier[];
  key: string;
  kind: string;
  name: unit | string;
  node: TSESTree.Node;
  flag: bigint;
  hint: bigint;
}
//#endregion
//#region src/component/component-flag.d.ts
type ComponentFlag = bigint;
declare const ComponentFlag: {
  None: bigint;
  PureComponent: bigint;
  CreateElement: bigint;
  Memo: bigint;
  ForwardRef: bigint;
  Async: bigint;
};
//#endregion
//#region src/component/component-semantic-node.d.ts
interface FunctionComponent extends SemanticNode {
  id: unit | TSESTree.Identifier | TSESTree.Identifier[];
  kind: "function";
  node: AST.TSESTreeFunction;
  flag: ComponentFlag;
  hint: ComponentDetectionHint;
  initPath: unit | AST.FunctionInitPath;
  hookCalls: TSESTree.CallExpression[];
  displayName: unit | TSESTree.Expression;
}
interface ClassComponent extends SemanticNode {
  id: unit | TSESTree.Identifier;
  kind: "class";
  node: AST.TSESTreeClass;
  flag: ComponentFlag;
  hint: ComponentDetectionHint;
  methods: AST.TSESTreeMethodOrProperty[];
  displayName: unit | TSESTree.Expression;
}
type Component = ClassComponent | FunctionComponent;
//#endregion
//#region src/component/component-collector.d.ts
type FunctionEntry = {
  key: string;
  node: AST.TSESTreeFunction;
  hookCalls: TSESTree.CallExpression[];
  isComponent: boolean;
};
declare namespace useComponentCollector {
  type Options = {
    collectDisplayName?: boolean;
    collectHookCalls?: boolean;
    hint?: ComponentDetectionHint;
  };
  type ReturnType = {
    ctx: {
      getAllComponents: (node: TSESTree.Program) => Map<string, FunctionComponent>;
      getCurrentEntries: () => FunctionEntry[];
      getCurrentEntry: () => FunctionEntry | unit;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
/**
 * Get a ctx and listeners for the rule to collect function components
 * @param context The ESLint rule context
 * @param options The options to use
 * @returns The component collector
 */
declare function useComponentCollector(context: RuleContext, options?: useComponentCollector.Options): useComponentCollector.ReturnType;
//#endregion
//#region src/component/component-collector-legacy.d.ts
declare namespace useComponentCollectorLegacy {
  type ReturnType = {
    ctx: {
      getAllComponents: (node: TSESTree$1.Program) => Map<string, ClassComponent>;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
/**
 * Get a ctx and listeners object for the rule to collect class components
 * @returns The context and listeners for the rule
 */
declare function useComponentCollectorLegacy(): useComponentCollectorLegacy.ReturnType;
//#endregion
//#region src/component/component-definition.d.ts
/**
 * Check whether given node is a function of a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;
/**
 * Determines if a function node represents a valid React component definition
 * @param context The rule context
 * @param node The function node to check
 * @param hint Component detection hints as bit flags
 * @returns `true` if the node is a valid component definition, `false` otherwise
 */
declare function isComponentDefinition(context: RuleContext, node: AST.TSESTreeFunction, hint: bigint): boolean;
//#endregion
//#region src/component/component-id.d.ts
declare function getFunctionComponentId(context: RuleContext, node: AST.TSESTreeFunction): TSESTree.Identifier | TSESTree.Identifier[] | unit;
//#endregion
//#region src/component/component-init-path.d.ts
declare function getComponentFlagFromInitPath(initPath: FunctionComponent["initPath"]): bigint;
//#endregion
//#region src/component/component-is.d.ts
/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-kind.d.ts
type ComponentKind = "classComponent" | "functionComponent";
//#endregion
//#region src/component/component-method.d.ts
declare const isRender: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentDidCatch: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentDidMount: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentDidUpdate: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentWillMount: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentWillReceiveProps: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentWillUnmount: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isComponentWillUpdate: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetChildContext: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetInitialState: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetSnapshotBeforeUpdate: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isShouldComponentUpdate: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isUnsafeComponentWillMount: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isUnsafeComponentWillReceiveProps: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isUnsafeComponentWillUpdate: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetDefaultProps: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetDerivedStateFromProps: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
declare const isGetDerivedStateFromError: (node: TSESTree.Node) => node is AST.TSESTreeMethodOrProperty;
//#endregion
//#region src/component/component-method-parts.d.ts
declare function isFunctionOfComponentDidMount(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentWillUnmount(node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-name.d.ts
declare function isComponentName(name: string): boolean;
declare function isComponentNameLoose(name: string): boolean;
declare function getComponentNameFromId(id: TSESTree.Identifier | TSESTree.Identifier[] | unit): string | undefined;
declare function hasNoneOrLooseComponentName(context: RuleContext, fn: AST.TSESTreeFunction): boolean;
//#endregion
//#region src/component/component-phase-helpers.d.ts
declare const isInversePhase: {
  (a: ComponentPhaseKind): (b: ComponentPhaseKind) => boolean;
  (a: ComponentPhaseKind, b: ComponentPhaseKind): boolean;
};
declare function getPhaseKindOfFunction(node: AST.TSESTreeFunction): ComponentPhaseKind | null;
//#endregion
//#region src/component/component-render-method.d.ts
/**
 * Check whether given node is a render method of a class component
 * @example
 * ```tsx
 * class Component extends React.Component {
 *   renderHeader = () => <div />;
 *   renderFooter = () => <div />;
 * }
 * ```
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderMethodLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
//#endregion
//#region src/component/component-render-prop.d.ts
/**
 * Unsafe check whether given node is a render function
 * ```tsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(context: RuleContext, node: AST.TSESTreeFunction): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```tsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(context: RuleContext, node: TSESTree.JSXAttribute): boolean;
/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```tsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```tsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;
//#endregion
//#region src/component/component-state.d.ts
type ComponentStateKind = "actionState" | "state";
declare function isThisSetState(node: TSESTree.CallExpression): boolean;
declare function isAssignmentToThisState(node: TSESTree.AssignmentExpression): boolean;
//#endregion
//#region src/component/component-wrapper.d.ts
/**
 * Check if the node is a call expression for a component wrapper
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper
 */
declare function isComponentWrapperCall(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Check if the node is a call expression for a component wrapper loosely
 * @param context The ESLint rule context
 * @param node The node to check
 * @returns `true` if the node is a call expression for a component wrapper loosely
 */
declare function isComponentWrapperCallLoose(context: RuleContext, node: TSESTree.Node): boolean;
//#endregion
//#region src/effect/effect-kind.d.ts
type EffectKind = "useEffect" | "useLayoutEffect" | "useInsertionEffect";
//#endregion
//#region src/hook/hook-semantic-node.d.ts
interface Hook extends SemanticNode {
  id: TSESTree.Identifier | unit;
  node: AST.TSESTreeFunction;
  name: string;
  hookCalls: TSESTree.CallExpression[];
}
//#endregion
//#region src/hook/hook-collector.d.ts
declare namespace useHookCollector {
  type ReturnType = {
    ctx: {
      getAllHooks(node: TSESTree$1.Program): Map<string, Hook>;
    };
    listeners: ESLintUtils.RuleListener;
  };
}
declare function useHookCollector(): useHookCollector.ReturnType;
//#endregion
//#region src/hook/hook-id.d.ts
declare function isReactHookId(id: TSESTree.Identifier | TSESTree.MemberExpression): boolean;
//#endregion
//#region src/hook/hook-is.d.ts
/**
 * Determines if a function node is a React Hook based on its name.
 * @param node The function node to check
 * @returns True if the function is a React Hook, false otherwise
 */
declare function isReactHook(node: AST.TSESTreeFunction | unit): boolean;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.Node | unit): node is TSESTree.CallExpression;
/**
 * Checks if a node is a call to a specific React hook.
 * Returns a function that accepts a hook name to check against.
 * @param node The AST node to check
 * @returns A function that takes a hook name and returns boolean
 */
declare function isReactHookCallWithName(node: TSESTree.Node | unit): (name: string) => boolean;
/**
 * Checks if a node is a call to a specific React hook or one of its aliases.
 * @param name The primary hook name to check
 * @param alias Optional array of alias names to also accept
 * @returns Function that checks if a node matches the hook name or aliases
 */
declare function isReactHookCallWithNameAlias(name: string, alias?: unit | string[]): (node: TSESTree.CallExpression) => boolean;
/**
 * Detects useEffect calls and variations (useLayoutEffect, etc.) using regex pattern.
 * @param node The AST node to check
 * @returns True if the node is a useEffect-like call
 */
declare function isUseEffectLikeCall(node: TSESTree.Node | unit): boolean;
declare const isUseCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseActionStateCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseCallbackCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseContextCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseDebugValueCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseDeferredValueCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseEffectCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseFormStatusCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseIdCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseImperativeHandleCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseInsertionEffectCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseLayoutEffectCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseMemoCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseOptimisticCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseReducerCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseRefCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseStateCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseSyncExternalStoreCall: (node: TSESTree.Node | undefined) => boolean;
declare const isUseTransitionCall: (node: TSESTree.Node | undefined) => boolean;
//#endregion
//#region src/hook/hook-name.d.ts
declare const REACT_BUILTIN_HOOK_NAMES: readonly ["use", "useActionState", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useFormStatus", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useOptimistic", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition"];
/**
 * Catch all identifiers that begin with "use" followed by an uppercase Latin
 * character to exclude identifiers like "user".
 * @param name The name of the identifier to check.
 * @see https://github.com/facebook/react/blob/1d6c8168db1d82713202e842df3167787ffa00ed/packages/eslint-plugin-react-hooks/src/rules/RulesOfHooks.ts#L16
 */
declare function isReactHookName(name: string): boolean;
//#endregion
//#region src/hook/hook-parts.d.ts
declare function isFunctionOfUseEffectSetup(node: TSESTree.Node | unit): boolean;
declare function isFunctionOfUseEffectCleanup(node: TSESTree.Node | unit): boolean;
//#endregion
//#region src/jsx/jsx-attribute.d.ts
declare function getAttribute(context: RuleContext, attributes: AST.TSESTreeJSXAttributeLike[], initialScope?: Scope): (name: string) => AST.TSESTreeJSXAttributeLike | undefined;
//#endregion
//#region src/jsx/jsx-attribute-name.d.ts
/**
 * Get the stringified name of a JSX attribute
 * @param context The ESLint rule context
 * @param node The JSX attribute node
 * @returns The name of the attribute
 */
declare function getAttributeName(context: RuleContext, node: TSESTree$1.JSXAttribute): string;
//#endregion
//#region src/jsx/jsx-attribute-value.d.ts
/**
 * Represents possible JSX attribute value types that can be resolved
 */
type AttributeValue = {
  kind: "boolean";
  toStatic(): true;
} | {
  kind: "element";
  node: TSESTree.JSXElement;
  toStatic(): unknown;
} | {
  kind: "literal";
  node: TSESTree.Literal;
  toStatic(): TSESTree.Literal["value"];
} | {
  kind: "expression";
  node: TSESTree.JSXExpressionContainer["expression"];
  toStatic(): unknown;
} | {
  kind: "spreadProps";
  node: TSESTree.JSXSpreadAttribute["argument"];
  toStatic(name?: string): unknown;
} | {
  kind: "spreadChild";
  node: TSESTree.JSXSpreadChild["expression"];
  toStatic(): unknown;
};
declare function resolveAttributeValue(context: RuleContext, attribute: AST.TSESTreeJSXAttributeLike): {
  readonly kind: "boolean";
  readonly toStatic: () => true;
  readonly node?: never;
} | {
  readonly kind: "literal";
  readonly node: TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral;
  readonly toStatic: () => string | number | bigint | boolean | RegExp | null;
} | {
  readonly kind: "expression";
  readonly node: TSESTree.JSXEmptyExpression | TSESTree.Expression;
  readonly toStatic: () => unknown;
} | {
  readonly kind: "element";
  readonly node: TSESTree.JSXElement;
  readonly toStatic: () => undefined;
} | {
  readonly kind: "spreadChild";
  readonly node: TSESTree.JSXEmptyExpression | TSESTree.Expression;
  readonly toStatic: () => undefined;
} | {
  readonly kind: "spreadProps";
  readonly node: TSESTree.Expression;
  readonly toStatic: (name?: string) => unknown;
};
//#endregion
//#region src/jsx/jsx-config.d.ts
declare const JsxEmit: {
  readonly None: 0;
  readonly Preserve: 1;
  readonly React: 2;
  readonly ReactNative: 3;
  readonly ReactJSX: 4;
  readonly ReactJSXDev: 5;
};
interface JsxConfig {
  jsx?: number;
  jsxFactory?: string;
  jsxFragmentFactory?: string;
  jsxImportSource?: string;
}
/**
 * Get JsxConfig from the rule context by reading compiler options.
 * @param context The RuleContext.
 * @returns JsxConfig derived from compiler options.
 */
declare function getJsxConfigFromContext(context: RuleContext): {
  jsx: 4 | typescript0.JsxEmit;
  jsxFactory: string;
  jsxFragmentFactory: string;
  jsxImportSource: string;
};
/**
 * Get JsxConfig from pragma comments (annotations) in the source code.
 * @param context The RuleContext.
 * @returns JsxConfig derived from pragma comments.
 */
declare function getJsxConfigFromAnnotation(context: RuleContext): JsxConfig;
//#endregion
//#region src/jsx/jsx-detection.d.ts
/**
 * BitFlags for configuring JSX detection behavior
 * Uses BigInt for bit operations to support many flags
 */
type JSXDetectionHint = bigint;
/**
 * Flags to control JSX detection behavior:
 * - Skip* flags: Ignore specific node types when detecting JSX
 * - Strict* flags: Enforce stricter rules for container types
 */
declare const JSXDetectionHint: {
  readonly None: 0n;
  readonly SkipUndefined: bigint;
  readonly SkipNullLiteral: bigint;
  readonly SkipBooleanLiteral: bigint;
  readonly SkipStringLiteral: bigint;
  readonly SkipNumberLiteral: bigint;
  readonly SkipBigIntLiteral: bigint;
  readonly SkipEmptyArray: bigint;
  readonly SkipCreateElement: bigint;
  readonly StrictArray: bigint;
  readonly StrictLogical: bigint;
  readonly StrictConditional: bigint;
};
/**
 * Default JSX detection configuration
 * Skips undefined and boolean literals (common in React)
 */
declare const DEFAULT_JSX_DETECTION_HINT: bigint;
/**
 * Checks if a node is a `JSXText` or a `Literal` node
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXText` or a `Literal` node
 */
declare function isJsxText(node: TSESTree$1.Node | null | unit): node is TSESTree$1.JSXText | TSESTree$1.Literal;
/**
 * Determines if a node represents JSX-like content based on heuristics
 * Supports configuration through hint flags to customize detection behavior
 *
 * @param code The source code with scope lookup capability
 * @param code.getScope The function to get the scope of a node
 * @param node The AST node to analyze
 * @param hint The configuration flags to adjust detection behavior
 * @returns boolean Whether the node is considered JSX-like
 */
declare function isJsxLike(code: {
  getScope: (node: TSESTree$1.Node) => Scope;
}, node: TSESTree$1.Node | unit | null, hint?: JSXDetectionHint): boolean;
//#endregion
//#region src/jsx/jsx-element-is.d.ts
/**
 * Determines if a JSX element is a host element
 * Host elements in React start with lowercase letters (e.g., div, span)
 *
 * @param context - ESLint rule context
 * @param node - AST node to check
 * @returns boolean indicating if the element is a host element
 */
declare function isHostElement(context: RuleContext, node: TSESTree.Node): boolean;
/**
 * Determines if a JSX element is a React Fragment
 * Fragments can be imported from React and used like <Fragment> or <React.Fragment>
 *
 * @param context - ESLint rule context
 * @param node - AST node to check
 * @returns boolean indicating if the element is a Fragment with type narrowing
 */
declare function isFragmentElement(context: RuleContext, node: TSESTree.Node): node is TSESTree.JSXElement;
//#endregion
//#region src/jsx/jsx-element-type.d.ts
/**
 * Extracts the element type name from a JSX element or fragment
 * For JSX elements, returns the stringified name (e.g., "div", "Button", "React.Fragment")
 * For JSX fragments, returns an empty string
 *
 * @param context - ESLint rule context
 * @param node - JSX element or fragment node
 * @returns String representation of the element type
 */
declare function getElementType(context: RuleContext, node: TSESTree.JSXElement | TSESTree.JSXFragment): string;
//#endregion
//#region src/jsx/jsx-has.d.ts
/**
 * Checks if a JSX element has a specific attribute
 *
 * @param context - ESLint rule context
 * @param name - Name of the attribute to check for
 * @param attributes - List of JSX attributes from opening element
 * @param initialScope - Optional scope for resolving variables in spread attributes
 * @returns boolean indicating whether the attribute exists
 */
declare function hasAttribute(context: RuleContext, name: string, attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
/**
 * Checks if a JSX element has at least one of the specified attributes
 *
 * @param context - ESLint rule context
 * @param names - Array of attribute names to check for
 * @param attributes - List of JSX attributes from opening element
 * @param initialScope - Optional scope for resolving variables in spread attributes
 * @returns boolean indicating whether any of the attributes exist
 */
declare function hasAnyAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
/**
 * Checks if a JSX element has all of the specified attributes
 *
 * @param context - ESLint rule context
 * @param names - Array of attribute names to check for
 * @param attributes - List of JSX attributes from opening element
 * @param initialScope - Optional scope for resolving variables in spread attributes
 * @returns boolean indicating whether all of the attributes exist
 */
declare function hasEveryAttribute(context: RuleContext, names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
//#endregion
//#region src/jsx/jsx-hierarchy.d.ts
/**
 * Traverses up the AST to find a parent JSX attribute node that matches a given test
 *
 * @param node - The starting AST node
 * @param test - Optional predicate function to test if the attribute meets criteria
 *               Defaults to always returning true (matches any attribute)
 * @returns The first matching JSX attribute node found when traversing upwards, or undefined
 */
declare function findParentAttribute(node: TSESTree.Node, test?: (node: TSESTree.JSXAttribute) => boolean): TSESTree.JSXAttribute | unit;
//#endregion
//#region src/jsx/jsx-stringify.d.ts
/**
 * Incomplete but sufficient stringification of JSX nodes for common use cases
 *
 * @param node - JSX node from TypeScript ESTree
 * @returns String representation of the JSX node
 */
declare function stringifyJsx(node: TSESTree$1.JSXIdentifier | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXClosingElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXText): string;
//#endregion
//#region src/utils/get-instance-id.d.ts
/**
 * Gets the identifier node of an instance based on AST node relationships.
 * Used for tracking where hooks or components are being assigned in the code.
 * @param node The current AST node to evaluate
 * @param prev The previous AST node in the traversal (used for context)
 * @internal
 */
declare function getInstanceId(node: TSESTree.Node, prev?: TSESTree.Node): TSESTree.ArrayExpression | TSESTree.ArrayPattern | TSESTree.ArrowFunctionExpression | TSESTree.AssignmentExpression | TSESTree.AwaitExpression | TSESTree.BinaryExpression | TSESTree.CallExpression | TSESTree.ChainExpression | TSESTree.ClassExpression | TSESTree.ConditionalExpression | TSESTree.FunctionExpression | TSESTree.Identifier | TSESTree.ImportExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.LogicalExpression | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.NewExpression | TSESTree.ObjectExpression | TSESTree.ObjectPattern | TSESTree.PrivateIdentifier | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.TemplateLiteral | TSESTree.ThisExpression | TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion | TSESTree.UnaryExpression | TSESTree.UpdateExpression | TSESTree.YieldExpression | undefined;
//#endregion
//#region src/utils/is-from-react.d.ts
/**
 * Check if an identifier name is initialized from react
 * @param name The top-level identifier's name
 * @param importSource The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier name is initialized from react
 * @internal
 */
declare function isInitializedFromReact(name: string, importSource: string, initialScope: Scope): boolean;
//#endregion
//#region src/utils/is-instance-id-equal.d.ts
/** @internal */
declare function isInstanceIdEqual(context: RuleContext, a: TSESTree.Node, b: TSESTree.Node): boolean;
//#endregion
//#region src/utils/is-react-api.d.ts
declare namespace isReactAPI {
  type ReturnType = {
    (context: RuleContext, node: unit | null | TSESTree.Node): node is TSESTree.Identifier | TSESTree.MemberExpression;
    (context: RuleContext): (node: unit | null | TSESTree.Node) => node is TSESTree.MemberExpression | TSESTree.Identifier;
  };
}
declare function isReactAPI(api: string): isReactAPI.ReturnType;
declare namespace isReactAPICall {
  type ReturnType = {
    (context: RuleContext, node: unit | null | TSESTree.Node): node is TSESTree.CallExpression;
    (context: RuleContext): (node: unit | null | TSESTree.Node) => node is TSESTree.CallExpression;
  };
}
declare function isReactAPICall(api: string): isReactAPICall.ReturnType;
declare const isCaptureOwnerStack: isReactAPI.ReturnType;
declare const isChildrenCount: isReactAPI.ReturnType;
declare const isChildrenForEach: isReactAPI.ReturnType;
declare const isChildrenMap: isReactAPI.ReturnType;
declare const isChildrenOnly: isReactAPI.ReturnType;
declare const isChildrenToArray: isReactAPI.ReturnType;
declare const isCloneElement: isReactAPI.ReturnType;
declare const isCreateContext: isReactAPI.ReturnType;
declare const isCreateElement: isReactAPI.ReturnType;
declare const isCreateRef: isReactAPI.ReturnType;
declare const isForwardRef: isReactAPI.ReturnType;
declare const isMemo: isReactAPI.ReturnType;
declare const isLazy: isReactAPI.ReturnType;
declare const isCaptureOwnerStackCall: isReactAPICall.ReturnType;
declare const isChildrenCountCall: isReactAPICall.ReturnType;
declare const isChildrenForEachCall: isReactAPICall.ReturnType;
declare const isChildrenMapCall: isReactAPICall.ReturnType;
declare const isChildrenOnlyCall: isReactAPICall.ReturnType;
declare const isChildrenToArrayCall: isReactAPICall.ReturnType;
declare const isCloneElementCall: isReactAPICall.ReturnType;
declare const isCreateContextCall: isReactAPICall.ReturnType;
declare const isCreateElementCall: isReactAPICall.ReturnType;
declare const isCreateRefCall: isReactAPICall.ReturnType;
declare const isForwardRefCall: isReactAPICall.ReturnType;
declare const isMemoCall: isReactAPICall.ReturnType;
declare const isLazyCall: isReactAPICall.ReturnType;
//#endregion
export { AttributeValue, ClassComponent, Component, ComponentDetectionHint, ComponentEffectPhaseKind, ComponentFlag, ComponentKind, ComponentLifecyclePhaseKind, ComponentPhaseKind, ComponentPhaseRelevance, ComponentStateKind, DEFAULT_COMPONENT_DETECTION_HINT, DEFAULT_JSX_DETECTION_HINT, EffectKind, FunctionComponent, Hook, JSXDetectionHint, JsxConfig, JsxEmit, REACT_BUILTIN_HOOK_NAMES, SemanticEntry, SemanticNode, findParentAttribute, getAttribute, getAttributeName, getComponentFlagFromInitPath, getComponentNameFromId, getElementType, getFunctionComponentId, getInstanceId, getJsxConfigFromAnnotation, getJsxConfigFromContext, getPhaseKindOfFunction, hasAnyAttribute, hasAttribute, hasEveryAttribute, hasNoneOrLooseComponentName, isAssignmentToThisState, isCaptureOwnerStack, isCaptureOwnerStackCall, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOfCreateElement, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDefinition, isComponentDidCatch, isComponentDidMount, isComponentDidUpdate, isComponentName, isComponentNameLoose, isComponentWillMount, isComponentWillReceiveProps, isComponentWillUnmount, isComponentWillUpdate, isComponentWrapperCall, isComponentWrapperCallLoose, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFragmentElement, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetChildContext, isGetDefaultProps, isGetDerivedStateFromError, isGetDerivedStateFromProps, isGetInitialState, isGetSnapshotBeforeUpdate, isHostElement, isInitializedFromReact, isInstanceIdEqual, isInversePhase, isJsxLike, isJsxText, isLazy, isLazyCall, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookId, isReactHookName, isRender, isRenderFunctionLoose, isRenderMethodLike, isRenderPropLoose, isShouldComponentUpdate, isThisSetState, isUnsafeComponentWillMount, isUnsafeComponentWillReceiveProps, isUnsafeComponentWillUpdate, isUseActionStateCall, isUseCall, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectLikeCall, isUseFormStatusCall, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseOptimisticCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, resolveAttributeValue, stringifyJsx, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
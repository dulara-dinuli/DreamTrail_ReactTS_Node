import { AST_NODE_TYPES, TSESTree } from "@typescript-eslint/types";
import { unit } from "@eslint-react/eff";
import { TSESTree as TSESTree$1 } from "@typescript-eslint/utils";

//#region src/array-index.d.ts
declare function getArrayMethodCallbackIndexParamPosition(methodName: string): number;
//#endregion
//#region src/array-method.d.ts
declare function isArrayFromCall(node: TSESTree.Node, loose?: boolean): node is TSESTree.CallExpression;
declare function isArrayMapCall(node: TSESTree.Node, loose?: boolean): node is TSESTree.CallExpression;
//#endregion
//#region src/node-equal.d.ts
/**
 * Determines whether node equals to another node
 * @param a node to compare
 * @param b node to compare
 * @returns `true` if node equal
 * @see https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/util/isNodeEqual.ts
 */
declare const isNodeEqual: {
  (a: TSESTree.Node): (b: TSESTree.Node) => boolean;
  (a: TSESTree.Node, b: TSESTree.Node): boolean;
};
//#endregion
//#region src/node-format.d.ts
/**
 * @internal
 */
declare function toDelimiterFormat(node: TSESTree.Node, delimiter?: string): "RegExp literal" | Lowercase<string> | `JSX ${Lowercase<string>}`;
/**
 * Incomplete but sufficient stringification of AST nodes for common use cases
 *
 * @internal
 */
declare function toStringFormat(node: TSESTree.Node, getText: (node: TSESTree.Node) => string): string;
//#endregion
//#region src/node-is.d.ts
declare const is: <NodeType extends TSESTree.AST_NODE_TYPES>(nodeType: NodeType) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
  type: NodeType;
}>;
declare const isOneOf: <NodeTypes extends readonly TSESTree.AST_NODE_TYPES[]>(nodeTypes: NodeTypes) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
  type: NodeTypes[number];
}>;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;
declare const isClass: (node: TSESTree.Node | null | undefined) => node is TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.ClassExpression;
declare const isMethodOrProperty: (node: TSESTree.Node | null | undefined) => node is TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName | TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName;
declare const isProperty: (node: TSESTree.Node | null | undefined) => node is TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName | TSESTree.TSIndexSignature | TSESTree.TSParameterProperty | TSESTree.TSPropertySignatureComputedName | TSESTree.TSPropertySignatureNonComputedName;
declare const isJSXElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXElement;
declare const isJSXFragment: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXFragment;
declare const isJSXTagNameExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName;
declare const isJSX: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXAttribute | TSESTree.JSXClosingElement | TSESTree.JSXClosingFragment | TSESTree.JSXElement | TSESTree.JSXEmptyExpression | TSESTree.JSXExpressionContainer | TSESTree.JSXFragment | TSESTree.JSXIdentifier | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName | TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment | TSESTree.JSXSpreadAttribute | TSESTree.JSXSpreadChild | TSESTree.JSXText;
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
declare const isTypeExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion;
declare const isTypeAssertionExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion;
//#endregion
//#region src/node-types.d.ts
type TSESTreeFunction = TSESTree$1.ArrowFunctionExpression | TSESTree$1.FunctionDeclaration | TSESTree$1.FunctionExpression;
type TSESTreeFunctionType = TSESTree$1.TSCallSignatureDeclaration | TSESTree$1.TSConstructSignatureDeclaration | TSESTree$1.TSDeclareFunction | TSESTree$1.TSEmptyBodyFunctionExpression | TSESTree$1.TSFunctionType | TSESTree$1.TSMethodSignature | TSESTreeFunction;
type TSESTreeClass = TSESTree$1.ClassDeclaration | TSESTree$1.ClassExpression;
type TSESTreeMethodOrProperty = TSESTree$1.PropertyDefinition | TSESTree$1.MethodDefinition;
type TSESTreeLoop = TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.WhileStatement;
type TSESTreeArrayTupleType = TSESTree$1.TSArrayType | TSESTree$1.TSTupleType;
type TSESTreeProperty = TSESTree$1.PropertyDefinition | TSESTree$1.TSIndexSignature | TSESTree$1.TSParameterProperty | TSESTree$1.TSPropertySignature;
type TSESTreeJSX = TSESTree$1.JSXAttribute | TSESTree$1.JSXChild | TSESTree$1.JSXClosingElement | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXElement | TSESTree$1.JSXEmptyExpression | TSESTree$1.JSXExpression | TSESTree$1.JSXExpressionContainer | TSESTree$1.JSXFragment | TSESTree$1.JSXIdentifier | TSESTree$1.JSXIdentifierToken | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXSpreadAttribute | TSESTree$1.JSXSpreadChild | TSESTree$1.JSXTagNameExpression | TSESTree$1.JSXText | TSESTree$1.JSXTextToken;
type TSESTreeJSXAttributeLike = TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute;
type TSESTreeDestructuringPattern = TSESTree$1.ArrayPattern | TSESTree$1.AssignmentPattern | TSESTree$1.ObjectPattern | TSESTree$1.RestElement;
type TSESTreeTypeDeclaration = TSESTree$1.TSInterfaceDeclaration | TSESTree$1.TSTypeAliasDeclaration;
type TSESTreeTypeExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion | TSESTree$1.TSInstantiationExpression;
type TSESTreeTypeAssertionExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion;
//#endregion
//#region src/class-id.d.ts
declare function getClassId(node: TSESTreeClass): TSESTree.Identifier | unit;
//#endregion
//#region src/expression-base.d.ts
/**
 * Unwraps any type expressions to get the underlying JavaScript expression node.
 * Recursively processes nodes until a non-type expression is found.
 *
 * @param node - The AST node to unwrap
 * @returns The underlying JavaScript expression node
 */
declare function getUnderlyingExpression(node: TSESTree.Node): Exclude<TSESTree.Node, TSESTreeTypeExpression>;
//#endregion
//#region src/expression-is.d.ts
/**
 * Checks if the given expression is a 'this' expression.
 * Unwraps any type expressions before checking.
 *
 * @param node - The expression node to check
 * @returns true if the expression is a ThisExpression, false otherwise
 */
declare function isThisExpression(node: TSESTree.Expression): boolean;
//#endregion
//#region src/expression-nested.d.ts
/**
 * Get all nested identifiers in a expression like node
 * @param node The node to get the nested identifiers from
 * @returns All nested identifiers
 */
declare function getNestedIdentifiers(node: TSESTree.Node): readonly TSESTree.Identifier[];
/**
 * Gets the nested return statements in the node that are within the same function
 * @param node The AST node
 * @returns The nested return statements in the node
 */
declare function getNestedReturnStatements(node: TSESTree.Node): readonly TSESTree.ReturnStatement[];
/**
 * Get all nested expressions of type T in an expression like node
 * @param type The type of the expression to retrieve within the node
 * @returns A partially applied function bound to a predicate of type T. The returned function can be called passing a
 * node, and it will return an array of all nested expressions of type T.
 */
declare function getNestedExpressionsOfType<TNodeType extends AST_NODE_TYPES>(type: TNodeType): (node: TSESTree.Node) => Extract<TSESTree.Node, {
  type: TNodeType;
}>[];
/**
 * Get all nested new expressions in an expression like node
 * @param node The node to get the nested new expressions from
 * @returns All nested new expressions
 */
declare const getNestedNewExpressions: (node: TSESTree.Node) => TSESTree.NewExpression[];
/**
 * Get all nested call expressions in a expression like node
 * @param node The node to get the nested call expressions from
 * @returns All nested call expressions
 */
declare const getNestedCallExpressions: (node: TSESTree.Node) => TSESTree.CallExpression[];
//#endregion
//#region src/function-id.d.ts
/**
 * Gets the static name of a function AST node. For function declarations it is
 * easy. For anonymous function expressions it is much harder. If you search for
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places
 * where JS gives anonymous function expressions names. We roughly detect the
 * same AST nodes with some exceptions to better fit our use case.
 */
declare function getFunctionId(node: TSESTree.Expression | TSESTreeFunction): TSESTree.Identifier | unit;
//#endregion
//#region src/function-init-path.d.ts
/**
 * Represents various AST paths for React component function declarations.
 * Each tuple type represents a specific component definition pattern.
 */
type FunctionInitPath = readonly [TSESTree.FunctionDeclaration] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTreeFunction] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.CallExpression, TSESTreeFunction] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.CallExpression, TSESTree.CallExpression, TSESTreeFunction] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTreeFunction] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTree.CallExpression, TSESTreeFunction] | readonly [TSESTree.VariableDeclaration, TSESTree.VariableDeclarator, TSESTree.ObjectExpression, TSESTree.Property, TSESTree.CallExpression, TSESTree.CallExpression, TSESTreeFunction] | readonly [TSESTree.ClassDeclaration, TSESTree.ClassBody, TSESTree.MethodDefinition, TSESTreeFunction] | readonly [TSESTree.ClassDeclaration, TSESTree.ClassBody, TSESTree.PropertyDefinition, TSESTreeFunction];
/**
 * Identifies the initialization path of a function node in the AST.
 * Determines what kind of component declaration pattern the function belongs to.
 *
 * @param node - The function node to analyze
 * @returns The function initialization path or unit if not identifiable
 */
declare function getFunctionInitPath(node: TSESTreeFunction): unit | FunctionInitPath;
/**
 * Checks if a specific function call exists in the function initialization path.
 * Useful for detecting HOCs like React.memo, React.forwardRef, etc.
 *
 * @param callName - The name of the call to check for (e.g., "memo", "forwardRef")
 * @param initPath - The function initialization path to search in
 * @returns True if the call exists in the path, false otherwise
 */
declare function hasCallInFunctionInitPath(callName: string, initPath: FunctionInitPath): boolean;
//#endregion
//#region src/function-is.d.ts
declare function isFunctionEmpty(node: TSESTreeFunction): boolean;
declare function isFunctionImmediatelyInvoked(node: TSESTreeFunction): boolean;
//#endregion
//#region src/literal.d.ts
declare function isLiteral(node: TSESTree.Node): node is TSESTree.Literal;
declare function isLiteral(node: TSESTree.Node, type: "boolean"): node is TSESTree.BooleanLiteral;
declare function isLiteral(node: TSESTree.Node, type: "null"): node is TSESTree.NullLiteral;
declare function isLiteral(node: TSESTree.Node, type: "number"): node is TSESTree.NumberLiteral;
declare function isLiteral(node: TSESTree.Node, type: "regexp"): node is TSESTree.RegExpLiteral;
declare function isLiteral(node: TSESTree.Node, type: "string"): node is TSESTree.StringLiteral;
//#endregion
//#region src/misc.d.ts
/**
 * Check if a node is multiline
 * @param node The AST node to check
 * @returns  `true` if the node is multiline
 */
declare function isMultiLine(node: TSESTree.Node): boolean;
/**
 * Check if a node is a line break
 * @param node The AST node to check
 * @returns boolean
 */
declare function isLineBreak(node: TSESTree.Node): boolean;
//#endregion
//#region src/node-selectors.d.ts
type ImplicitReturnArrowFunctionExpression = TSESTree$1.ArrowFunctionExpression & {
  body: TSESTree$1.Expression;
};
type ObjectDestructuringVariableDeclarator = TSESTree$1.VariableDeclarator & {
  id: TSESTree$1.ObjectPattern;
  init: TSESTree$1.Identifier;
};
type DisplayNameAssignmentExpression = TSESTree$1.AssignmentExpression & {
  type: "AssignmentExpression";
  left: TSESTree$1.MemberExpression & {
    property: TSESTree$1.Identifier & {
      name: "displayName";
    };
  };
  operator: "=";
  right: TSESTree$1.Literal;
};
declare const SEL_IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION = "ArrowFunctionExpression[body.type!='BlockStatement']";
declare const SEL_OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: string;
declare const SEL_DISPLAY_NAME_ASSIGNMENT_EXPRESSION: string;
//#endregion
//#region src/process-env-node-env.d.ts
/**
 * Check if the given node is a member expression that accesses `process.env.NODE_ENV`
 * @param node The AST node
 * @returns True if the node is a member expression that accesses `process.env.NODE_ENV`, false otherwise
 */
declare function isProcessEnvNodeEnv(node: TSESTree.Node | null | unit): node is TSESTree.MemberExpression;
/**
 * Check if the given node is a binary expression that compares `process.env.NODE_ENV` with a string literal.
 * @param node The AST node
 * @param operator The operator used in the comparison
 * @param value The string literal value to compare against
 * @returns True if the node is a binary expression that compares `process.env.NODE_ENV` with the specified value, false otherwise
 */
declare function isProcessEnvNodeEnvCompare(node: TSESTree.Node | null | unit, operator: "===" | "!==", value: "development" | "production"): node is TSESTree.BinaryExpression;
//#endregion
//#region src/promise-then.d.ts
declare function isThenCall(node: TSESTree.CallExpression): boolean;
//#endregion
//#region src/property-name.d.ts
declare function getPropertyName(node: TSESTree.Node): string | unit;
//#endregion
//#region src/traverse-up.d.ts
/**
 * Find the parent node that satisfies the test function
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function or `_` if not found
 */
declare function findParentNode<A extends TSESTree.Node>(node: TSESTree.Node | unit, test: (n: TSESTree.Node) => n is A): A | unit;
/**
 * Find the parent node that satisfies the test function or `_` if not found
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function
 */
declare function findParentNode(node: TSESTree.Node | unit, test: (node: TSESTree.Node) => boolean): TSESTree.Node | unit;
//#endregion
//#region src/vitest-mock.d.ts
/**
 * Checks if the given node is a `vi.mock`.
 * @param node The node to check
 * @returns `true` if the node is a `vi.mock`, otherwise `false`.
 * @internal
 */
declare function isViMock(node: TSESTree.Node | null | unit): node is TSESTree.MemberExpression;
/**
 * Checks if the given node is a `vi.mock` callback.
 * @param node The node to check
 * @returns `true` if the node is a `vi.mock` callback, otherwise `false`.
 * @internal
 */
declare function isViMockCallback(node: TSESTree.Node | null | unit): boolean;
//#endregion
export { DisplayNameAssignmentExpression, FunctionInitPath, ImplicitReturnArrowFunctionExpression, ObjectDestructuringVariableDeclarator, SEL_DISPLAY_NAME_ASSIGNMENT_EXPRESSION, SEL_IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION, SEL_OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR, TSESTreeArrayTupleType, TSESTreeClass, TSESTreeDestructuringPattern, TSESTreeFunction, TSESTreeFunctionType, TSESTreeJSX, TSESTreeJSXAttributeLike, TSESTreeLoop, TSESTreeMethodOrProperty, TSESTreeProperty, TSESTreeTypeAssertionExpression, TSESTreeTypeDeclaration, TSESTreeTypeExpression, findParentNode, getArrayMethodCallbackIndexParamPosition, getClassId, getFunctionId, getFunctionInitPath, getNestedCallExpressions, getNestedExpressionsOfType, getNestedIdentifiers, getNestedNewExpressions, getNestedReturnStatements, getPropertyName, getUnderlyingExpression, hasCallInFunctionInitPath, is, isArrayFromCall, isArrayMapCall, isClass, isFunction, isFunctionEmpty, isFunctionImmediatelyInvoked, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isLineBreak, isLiteral, isLoop, isMethodOrProperty, isMultiLine, isNodeEqual, isOneOf, isProcessEnvNodeEnv, isProcessEnvNodeEnvCompare, isProperty, isThenCall, isThisExpression, isTypeAssertionExpression, isTypeExpression, isViMock, isViMockCallback, toDelimiterFormat, toStringFormat };